<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">

        <title>software development</title>

        <!-- Bootstrap core CSS -->
        <link href="css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom styles for this template -->
        <link href="css/blog.css" rel="stylesheet">
    </head>

    <body>

        <div class="blog-masthead">
            <div class="container">
                <nav class="blog-nav">
                    <a class="blog-nav-item" href="index.html">home</a>
                    <a class="blog-nav-item" href="coderwurstBlog.html">journal</a>
                    <a class="blog-nav-item" href="softwareDev.html">software crafting</a>
                    <a class="blog-nav-item" href="mobileApps.html">mobile applications</a>
                    <a class="blog-nav-item" href="aboutme.html">about me</a>
                </nav>
            </div>
        </div>

        <div class="container">

            <div class="blog-header">
                <br>
                <h1 align="left"><b>coderwurst</b></h1>
                <p class="lead blog-description">chapter 8 - understanding polymorphism and casts</p>
            </div>

            <div class="row">

                <div class="col-sm-8 blog-main">

                    <div class="blog-post" id="main">
                                <br>
                                <b>Polymorphism</b>
                                <ul>
                                <li>concept of allowing a dev to write generic code which is flexible and can be reused</li>
                                <li>polymorphism means many forms in Greek</li>
                                <li>it can exist when 1 class inherits from another, or when a class implements an interface</li>
                                </ul>

                                <b>Polymorphism via class inheritance</b><ul>
                                <li>Polymorphism utilises the "is-a" relationship</li>
                                <li>eg a Child is-a Human object, both Child and Human are a Human Object,] Both Joe and Mary are an Adult Object which is a Human Object</li>
                                <li>any subclass object is a more specific type of its parent object, inherits methods form the parent and is said to be polymorphically used as that object</li>
                                <li>one of the benefits of polymorphism is that the Java code does not always have to be aware of the specifics of an object</li>
                                <li>in general, as long as an object meets the needs of a method, Java does not care whether it is general or specific</li>
                                <li>the only requirement is that the object has an is-a relationship with the object that the method requires</li>
                                <li>this relationship is uni-directional; a parent object cannot inherit from a more specific child object (see below instantiating example)</li>
                                <li><b>NOTE</b> for exam that the only way to assign an object to an abstract data type is by using polymorphism (abstract cannot be initialised)</li>
                                </ul>

                                <b>Polymorphism via implementing interfaces</b><ul>
                                <li>classes implement interfaces to guarantee the functionality that the interface defines, which allows classes creates from these to be treated as instances of the interface</li>
                                <li>this results in any class that implements an interface having an 'is-a' relationship with the interface</li>
                                <li>this object can now masquerade as an object of the interface type, and therefore polymorphically act as any interface that its class or superclass implements</li>
                                <li>this is very common code practice in large software projects</li>
                                </ul>

                                <b>Polymorphism in Code</b><ul>
                                <li>when one specific object can be used as another polymorphically, the specific object can be used in place of the general one without being cast</li>
                                </ul>

                                <pre><code>Type C extends Type B ...Type A extends Type B ...
Type A var1 = new Type A();
Type A var2 = new Type B();
Type A var3 = new Type C();
<br />
Type B var5 = new Type B();Type B var6 = new Type C();<br />
Type C var7 = new Type C();<br /></code></pre>
                                <ul>
                                <li>any subclass can be used interchangably with its superclass</li>
                                <li>once initiated as above, the subclass objects on the right will be treated like the superclass declarations on the left</li>
                                <li>this is ok as the subclass must have inherited all of the functionality from the TypeA and TypeB objects</li>
                                <li>however, this is uni directional; for example, if Type C objects have additional methods that are not part of the Type A class, they are unavailable to the var3 object</li>
                                <li>most commonly polymorphism is used to accommodate differences in method arguments</li>
                                </ul>

                                <b>Programming to an interface</b><ul>
                                <li>code concept that code should interact based on a defined set of functionalty instead of an explicitly defined object type</li>
                                <li>i.e. it is better for public interdaces to use data types that are defined as interfaces as opposed to a particular class where possible</li>
                                <li>when an object is implementing an interdace, it is declaring that it has a certain set of functionalities - think of a contract</li>
                                <li>many classes can implement the same interface, allowing more code to be abstract and flexible</li>
                                <li>programming to an interface can also be known as <b>design by contract</b></li>
                                </ul>

                                <br />

                                <b>Casting</b><ul>
                                <li>polymorphism involves a subclass to a superclass, casting allows for the opposite - taking an object that is more general and making it specific</li>
                                <li>casting allows you to convert an object back to its original runtime type or any of its superclasses</li>
                                <li>when converting primitive data to another type, it can cause some data to be lost - this is why we need casting</li>
                                <li>because there is a chance of incomparable data types, the Java compiler requires that we state the data type we intend to use</li>
                                <li>typical examples include a float to a double or a hashmap to a linkedhashmap</li>
                                </ul>

                                double detailedScore = 1.2;float moreDetailedScore = (float) detailedScore;<br />
                                <b>Casting Primitives</b><ul>
                                <li>if we needed to store an int (1236) as a byte, data would be lost die to the amount of memory space a byte has (min -128, 127)</li>
                                <li>the compiler will still allow this int to be cast as a byte, however the output will be truncated (-44)</li>
                                <li>this is not as simple as having only 2 of the 5 digits above,a completely different value will be output due to binary representation</li>
                                <li>as well as having less bits to store the number, the significant bit (most left) is 1 instead of 0, creating a minus number</li>
                                </ul>

                                <br />
                                <br />
                                <b>Casting between Primitives and Objects</b><ul>
                                <li>available since Java 5, also with an automatic boxing and unboxing feature - which means that the proper conversion is done automatically</li>
                                <li>a.k.a. <b>hidden casting</b></li>
                                </ul>

                                <br>
                                <b>Casting Objects</b><ul>
                                <li>An object can polymorphically become any object that is its superclass</li>
                                <li>once an object is assigned a more general type, it can no longer access its more specific features</li>
                                <li>an object has to eb cast back to its original runtime type to use these features</li>
                                <li>the object to be cast MUST have been instantiated as that object, or an object inherited from it</li>
                                </ul>

                                <pre><code>public class ClassA {<br />
    public String whoAmI() {
        return "classA"; 
    } 

    public String specialClassAMethod() { 
        return "ClassA only method";
    }<br />
                                
}

<br />
    public class ClassB extends ClassA {<br />
        public String whoAmI() { 
            return "classB"; 
        } 

    public String specialClassBMethod() {
            return "ClassB only method"; 
        }
}<br />
                                

ClassB obj1 = new ClassB();
ClassA obj2 = new ClassB(); // polymorphismC
lassA obj3 = new ClassA();<br />
                                <br />

sout("obj1" + obj1.whoAmI());sout("obj2" + obj2.whoAmI());sout("obj3" + obj3.whoAmI());<<br />


output:obj1: ClassBobj2: ClassBobj3: ClassA<br /> </code></pre>
                                
                                <ul>
                                <li>ClassB overrides whoAmI method and has a unique ClassB method</li>
                                <li>obj2 is instantiated as ClassA but initialised with ClassB - therefore ClassB special method is not available, and a call to this method would not compile</li>
                                <li>it could be cast back to ClassB</li>
                                </ul>
<pre><code>
ClassB obj4 = (ClassB)obj2;
sout("obj4" + obj4.specialClassBMethod());<br />
                                OR<br />
sout("obj2" + ((ClassB)obj2).specialClassBMethod());
<br /> </code></pre>
                                <ul>
                                <li>note that objB cannot be cast as a CastB object</li>
                                </ul>

                                <br />
                                <b>REMEMBER:polymorphism - subclass to superclass, going up chaincasting - superclass to subclass, going down chain</b><br />
                                <ul>
                                <li>can and should always check if a cast will work by using the <b>instanceOf</b> operator</li>
                                </ul>
                                <br>

                        </div>

                    </div><!-- /.blog-main -->



                
                <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
                    <div class="sidebar-module">
                        <br>
                        <h4><b>coderwurst elsewhere</b></h4>
                        <ol class="list-unstyled">
                            <li><a href="https://twitter.com/coderwurst">twitter</a></li>
                            <li><a href="https://www.linkedin.com/pub/andrew-mcmechan/37/251/849">LinkedIn</a></li>
                            <li><a href="https://www.flickr.com/photos/coderwurst/">flickr</a></li>
                        </ol>
                    </div>
                </div><!-- /.blog-sidebar -->

                </div><!-- /.row -->

            </div><!-- /.container -->
    </body>

    <footer class="blog-footer">
                <p>Blog template built for <a href="http://getbootstrap.com">Bootstrap</a> by <a href="https://twitter.com/mdo">@mdo</a>,</p>
                <p>Continual progressive enhancement by <a href="https://twitter.com/coderwurst">@coderwurst</a>.</p>
                <p>
                    <a href="#">Back to top</a>
                </p>
            </footer>
</html>
